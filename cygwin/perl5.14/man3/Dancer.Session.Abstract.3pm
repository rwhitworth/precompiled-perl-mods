.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Dancer::Session::Abstract 3"
.TH Dancer::Session::Abstract 3 "2015-07-03" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dancer::Session::Abstract \- abstract class for session engine
.SH "VERSION"
.IX Header "VERSION"
version 1.3140
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This virtual class describes how to build a session engine for Dancer. This is
done in order to allow multiple session storage backends with a common interface.
.PP
Any session engine must inherit from Dancer::Session::Abstract and implement
the following abstract methods.
.SS "Configuration"
.IX Subsection "Configuration"
These settings control how a session acts.
.PP
\fIsession_name\fR
.IX Subsection "session_name"
.PP
The default session name is \*(L"dancer_session\*(R". This can be set in your config file:
.PP
.Vb 1
\&    setting session_name: "mydancer_session"
.Ve
.PP
\fIsession_domain\fR
.IX Subsection "session_domain"
.PP
Allows you to set the domain property on the cookie, which will
override the default.  This is useful for setting the session cookie's
domain to something like \f(CW\*(C`.domain.com\*(C'\fR so that the same cookie will
be applicable and usable across subdomains of a base domain.
.PP
\fIsession_secure\fR
.IX Subsection "session_secure"
.PP
The user's session id is stored in a cookie.  If true, this cookie
will be made \*(L"secure\*(R" meaning it will only be served over https.
.PP
\fIsession_expires\fR
.IX Subsection "session_expires"
.PP
When the session should expire.  The format is either the number of
seconds in the future, or the human readable offset from
\&\*(L"expires\*(R" in Dancer::Cookie.
.PP
By default, there is no expiration.
.PP
\fIsession_is_http_only\fR
.IX Subsection "session_is_http_only"
.PP
This setting defaults to 1 and instructs the session cookie to be
created with the \f(CW\*(C`HttpOnly\*(C'\fR option active, meaning that JavaScript
will not be able to access to its value.
.SS "Abstract Methods"
.IX Subsection "Abstract Methods"
.IP "\fBretrieve($id)\fR" 4
.IX Item "retrieve($id)"
Look for a session with the given id, return the session object if found, undef
if not.
.IP "\fB\f(BIcreate()\fB\fR" 4
.IX Item "create()"
Create a new session, return the session object.
.IP "\fB\f(BIflush()\fB\fR" 4
.IX Item "flush()"
Write the session object to the storage engine.
.IP "\fB\f(BIdestroy()\fB\fR" 4
.IX Item "destroy()"
Remove the current session object from the storage engine.
.IP "\fBsession_name\fR (optional)" 4
.IX Item "session_name (optional)"
Returns a string with the name of cookie used for storing the session \s-1ID\s0.
.Sp
You should probably not override this; the user can control the cookie name
using the \f(CW\*(C`session_name\*(C'\fR setting.
.IP "\fBget_value($key)\fR" 4
.IX Item "get_value($key)"
Retrieves the value associated with the key.
.ie n .IP "\fBset_value($key, \fB$value\fB)\fR" 4
.el .IP "\fBset_value($key, \f(CB$value\fB)\fR" 4
.IX Item "set_value($key, $value)"
Stores the value associated with the key.
.SS "Inherited Methods"
.IX Subsection "Inherited Methods"
The following methods are not supposed to be overloaded, they are generic and
should be \s-1OK\s0 for each session engine.
.IP "\fBbuild_id\fR" 4
.IX Item "build_id"
Build a new uniq id.
.IP "\fBread_session_id\fR" 4
.IX Item "read_session_id"
Reads the \f(CW\*(C`dancer.session\*(C'\fR cookie.
.IP "\fBwrite_session_id\fR" 4
.IX Item "write_session_id"
Write the current session id to the \f(CW\*(C`dancer.session\*(C'\fR cookie.
.IP "\fBis_lazy\fR" 4
.IX Item "is_lazy"
Default is false.  If true, session data will not be flushed after every
modification and the session engine (or application) will need to ensure
that a flush is called before the end of the request.
.SH "SPEC"
.IX Header "SPEC"
.IP "\fBrole\fR" 4
.IX Item "role"
A Dancer::Session object represents a session engine and should provide anything
needed to manipulate a session, whatever its storing engine is.
.IP "\fBid\fR" 4
.IX Item "id"
The session id will be written to a cookie, by default named \f(CW\*(C`dancer.session\*(C'\fR,
it is assumed that a client must accept cookies to be able to use a
session-aware Dancer webapp. (The cookie name can be change using the
\&\f(CW\*(C`session_name\*(C'\fR config setting.)
.IP "\fBstorage engine\fR" 4
.IX Item "storage engine"
When the session engine is enabled, a \fIbefore\fR filter takes care to initialize
the appropriate session engine (according to the setting \f(CW\*(C`session\*(C'\fR).
.Sp
Then, the filter looks for a cookie named \f(CW\*(C`dancer.session\*(C'\fR (or whatever you've
set the \f(CW\*(C`session_name\*(C'\fR setting to, if you've used it) in order to
\&\fIretrieve\fR the current session object. If not found, a new session object is
\&\fIcreated\fR and its id written to the cookie.
.Sp
Whenever a session call is made within a route handler, the singleton
representing the current session object is modified.
.Sp
A \fIflush\fR is made to the session object after every modification unless
the session engine overrides the \f(CW\*(C`is_lazy\*(C'\fR method to return true.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dancer Core Developers
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2010 by Alexis Sukrieh.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
