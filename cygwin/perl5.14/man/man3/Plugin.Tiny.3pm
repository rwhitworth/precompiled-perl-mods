.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "Plugin::Tiny 3"
.TH Plugin::Tiny 3 "2014-01-23" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Plugin::Tiny \- A tiny plugin system for perl
.SH "VERSION"
.IX Header "VERSION"
version 0.012
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  #a complete \*(AqHello World\*(Aq plugin
\&  package My::Plugin; 
\&  use Moose; #optional; required is an object with new as constructor
\&  sub do_something { print "Hello World @_\en" }
\&  1;
\&
\&
\&  #in your core
\&  use Plugin::Tiny;           
\&  my $ps=Plugin::Tiny\->new(); #plugin system
\&  
\&  #load My::Plugin: require, import, return My::Plugin\->new(@_)
\&  my $plugin=$ps\->register(plugin=>\*(AqMy::Plugin\*(Aq);
\&
\&
\&  #elsewhere in core: execute your plugin\*(Aqs methods 
\&  my $plugin=$ps\->get_plugin ($phase); 
\&  $plugin\->do_something(@args);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Plugin::Tiny is minimalistic plugin system for perl. Each plugin is associated
with a keyword (referred to as phase). A limitation of Plugin::Tiny is that 
each phase can have only one plugin.
.PP
Plugin::Tiny calls itself tiny because it doesn't attempt to solve all problems
plugin systems could solve, because it consists of one smallish package, and it 
doesn't depend on a whole lot.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "debug"
.IX Subsection "debug"
Optional. Expects a boolean. Prints additional info to \s-1STDOUT\s0.
.SS "prefix"
.IX Subsection "prefix"
Optional. You can have the prefix added to all plugin classes you
register so save some typing and force plugins in your namespace:
.PP
.Vb 4
\&  #without prefix  
\&  my $ps=Plugin::Tiny\->new  
\&  $ps\->register(plugin=\*(AqYour::App::Plugin::Example1\*(Aq);
\&  $ps\->register(plugin=\*(AqYour::App::Plugin::Example2\*(Aq);
\&
\&  #with prefix  
\&  my $ps=Plugin::Tiny\->new (  prefix=>\*(AqYour::App::Plugin::\*(Aq );  
\&  $ps\->register(plugin=\*(AqExample1\*(Aq);
\&  $ps\->register(plugin=\*(AqExample2\*(Aq);
.Ve
.SS "role"
.IX Subsection "role"
Optional. One or more roles that all plugins have to be able to do. Can be 
overwritten in \f(CW\*(C`register\*(C'\fR.
.PP
.Vb 2
\&    role=>[\*(AqRole::One\*(Aq, Role::Two]      #either as ArrayRef 
\&    role=>\*(AqRole::One\*(Aq                   #or a scalar
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "register"
.IX Subsection "register"
Registers a plugin, i.e. loads it and makes a new plugin object. Needs a
plugin package name (plugin). Returns the newly created plugin object on 
success. Confesses on error. Remaining arguments are passed down to the 
plugin constructor:
.PP
.Vb 4
\&    $obj=$ps\->register(
\&        plugin=>$plugin_class,   #required
\&        args=>$more_args,        #optional
\&    ); #returns result of $plugin_class\->new (args=>$args);
.Ve
.PP
N.B. Your plugin cannot use 'phase', 'plugin', 'role', 'force' as named 
arguments.
.IP "\fBplugin\fR" 4
.IX Item "plugin"
The package name of the plugin. Required. Internally, the value of \f(CW\*(C`prefix\*(C'\fR
is prepended to plugin.
.IP "\fBphase\fR" 4
.IX Item "phase"
A phase asociated with the plugin. Optional. If not specified, Plugin::Tiny 
uses \f(CW\*(C`default_phase\*(C'\fR to determine the phase.
.IP "\fBrole\fR" 4
.IX Item "role"
One or more roles that the plugin has to appply. Optional. Specify role=>undef 
to unset global roles. Currently, you can't mix global roles (defined via new) 
with local roles (defined via register).
.Sp
.Vb 3
\&    role=>\*(AqSingle::Role\*(Aq #or
\&    role=>[\*(AqRole::One\*(Aq,\*(AqRole:Two\*(Aq]
\&    role=>undef #unset global roles
.Ve
.IP "\fBforce\fR" 4
.IX Item "force"
Force re-registration of a previously used phase. Optional.
.Sp
Normally, Plugin::Tiny confesses if you try to register a phase that has 
previously been assigned. To overwrite this message make force true.
.Sp
With force both plugins will be loaded (required, imported) and both return new 
objects for their respective plugin classes, but after the second plugin is 
made, the first one cannot be accessed anymore through get_plugin.
.SS "register_bundle"
.IX Subsection "register_bundle"
Registers a bundle of plugins in no particular order. A bundle is just a 
hashRef with info needed to issue a series of register calls (see \f(CW\*(C`register\*(C'\fR).
.PP
Confesses if a plugin cannot be registered. Otherwise returns \f(CW$bundle\fR or undef.
.PP
.Vb 10
\&  sub bundle{
\&    return {
\&      \*(AqStore::One\*(Aq => {   
\&          phase  => \*(AqStore\*(Aq,
\&          role   => undef,
\&          dbfile => $self\->core\->config\->{main}{dbfile},
\&        },
\&       \*(AqScan::Monitor\*(Aq=> {   
\&          core   => $self\->core
\&        },
\&    };
\&  }
\&  $ps\->register_bundle(bundle)
.Ve
.PP
If you want to add or remove plugins, use hashref as usual:
.PP
.Vb 2
\&  undef $bundle\->{$plugin};                #remove a plugin using package name
\&  $bundle\->{\*(AqMy::Plugin\*(Aq}={phase=>\*(Aqfoo\*(Aq};  #add another plugin
.Ve
.PP
To facilitate inheritance of your plugins perhaps you put the hashref in a 
separate sub, so a child bundle can extend or remove plugins from yours.
.SS "get_plugin"
.IX Subsection "get_plugin"
Returns the plugin object associated with the phase. Returns undef on failure.
.PP
.Vb 1
\&  my $plugin=$ps\->get_plugin ($phase);
.Ve
.SS "default_phase"
.IX Subsection "default_phase"
Makes a default phase from (the plugin's) class name. Expects a \f(CW$plugin_class\fR. 
Returns scalar or undef. If prefix is defined it use tail and removes all '::'. 
If no prefix is set default_phase returns the last element of the class name:
.PP
.Vb 2
\&    my $ps=Plugin\-Tiny\->new;
\&    $ps\->default_phase(My::Plugin::Long::Example); #returns \*(AqExample\*(Aq
\&
\&    $ps=Plugin\-Tiny\->new(prefix=>\*(AqMy::Plugin::\*(Aq);
\&    $ps\->default_phase(My::Plugin::Long::Example); #returns \*(AqLongExample\*(Aq
.Ve
.SS "get_class"
.IX Subsection "get_class"
Returns the plugin's class (package name). Expects plugin (not its package 
name). Croaks on error.
.PP
.Vb 1
\&  my $class=$ps\->get_class ($plugin);
.Ve
.SS "get_phase"
.IX Subsection "get_phase"
returns the plugin's phase. Expects plugin (not its package name). Returns 
undef on failure. (You will not normally need get_phase, because typically your 
code knows the phases.)
.PP
.Vb 1
\&  my $phase=$ps\->get_phase ($plugin);
.Ve
.SH "Recommendation: First Register Then Do Things"
.IX Header "Recommendation: First Register Then Do Things"
Plugin::Tiny suggests that you first register (load) all your plugins before 
you actually do something with them. Internal \f(CW\*(C`require\*(C'\fR / \f(CW\*(C`use\*(C'\fR of your 
packages is deferred until runtime. You can control the order in which plugins 
are loaded (in the order you call \f(CW\*(C`register\*(C'\fR), but if you manage to load all 
of them before you do anything, you can forget about order.
.PP
You may know Plugin::Tiny's phases at compile time, but not which plugins will 
be loaded.
.SH "Recommendation: Require a Plugin Role"
.IX Header "Recommendation: Require a Plugin Role"
You may want to do a plugin role for all you plugins, e.g. to standardize
the interface for your plugins. Perhaps to make sure that a specific sub is
available in the plugin:
.PP
.Vb 4
\&  package My::Plugin; 
\&  use Moose;
\&  with \*(AqYour::App::Role::Plugin\*(Aq;
\&  #...
.Ve
.SH "Plugin Bundles"
.IX Header "Plugin Bundles"
You can create bundles of plugins if you pass the plugin system to the 
(bundling) plugin. That way you can load multiple plugins for one phase. You 
still need unique phases for each plugin:
.PP
.Vb 7
\&  package My::Core;
\&  use Moose; 
\&  has \*(Aqplugin_system\*(Aq=>(
\&    is=>\*(Aqro\*(Aq,
\&    isa=>\*(AqPlugin::Tiny\*(Aq, 
\&    default=>sub{Plugin::Tiny\->new},
\&  );
\&
\&  sub BUILD {
\&    $self\->plugins\->register(
\&      plugin=>\*(AqPluginBundle\*(Aq, 
\&      phase=>\*(AqBundle\*(Aq,
\&      plugin_system=>$self\->plugins, 
\&    );
\&  }
\&
\&  #elsewhere in core
\&  my $b=$self\->plugin_system\->get_plugin (\*(AqBundle\*(Aq);  
\&  $b\->start();
\&
\&
\&  package PluginBundle;
\&  use Moose;
\&  has \*(Aqplugin_system\*(Aq=>(is=>\*(Aqro\*(Aq, isa=>\*(AqPlugin::Tiny\*(Aq, required=>1); 
\&
\&  sub bundle {
\&      {Plugin::One=>{},Plugin::Two=>{}}
\&  }  
\&  sub BUILD {
\&    #phase defaults to \*(AqOne\*(Aq and \*(AqTwo\*(Aq:
\&    $self\->plugins\->register_bundle(bundle());
\&  
\&    #more or less the same as:    
\&    #$self\->plugins\->register (plugin=>\*(AqPlugin::One\*(Aq);  
\&    #$self\->plugins\->register (plugin=>\*(AqPlugin::Two\*(Aq); 
\&  }
\&  
\&  sub start {
\&    my $one=$self\->plugins\->get(\*(AqOne\*(Aq);
\&    $one\->do_something(@args);  
\&  }
.Ve
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Thanks to Toby Inkster for making Plugin::Tiny tinier.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Object::Pluggable 
Module::Pluggable
MooX::Role::Pluggable
MooseX::Object::Pluggable
MooseX::Role::Pluggable
.SH "AUTHOR"
.IX Header "AUTHOR"
Maurice Mengel <mauricemengel@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Maurice Mengel.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
