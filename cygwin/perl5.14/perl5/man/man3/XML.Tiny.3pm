.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "XML::Tiny 3"
.TH XML::Tiny 3 "2010-12-16" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Tiny \- simple lightweight parser for a subset of XML
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::Tiny is a simple lightweight parser for a subset of \s-1XML\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use XML::Tiny qw(parsefile);
\&    open($xmlfile, \*(Aqsomething.xml);
\&    my $document = parsefile($xmlfile);
.Ve
.PP
This will leave \f(CW$document\fR looking something like this:
.PP
.Vb 12
\&    [
\&        {
\&            type   => \*(Aqe\*(Aq,
\&            attrib => { ... },
\&            name   => \*(Aqrootelementname\*(Aq,
\&            content => [
\&                ...
\&                more elements and text content
\&                ...
\&           ]
\&        }
\&    ]
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The \f(CW\*(C`parsefile\*(C'\fR function is optionally exported.  By default nothing is
exported.  There is no objecty interface.
.SS "parsefile"
.IX Subsection "parsefile"
This takes at least one parameter, optionally more.  The compulsory
parameter may be:
.IP "a filename" 4
.IX Item "a filename"
in which case the file is read and parsed;
.IP "a string of \s-1XML\s0" 4
.IX Item "a string of XML"
in which case it is read and parsed.  How do we tell if we've got a string
or a filename?  If it begins with \f(CW\*(C`_TINY_XML_STRING_\*(C'\fR then it's
a string.  That prefix is, of course, ignored when it comes to actually
parsing the data.  This is intended primarily for use by wrappers which
want to retain compatibility with Ye Aunciente Perl.  Normal users who want
to pass in a string would be expected to use IO::Scalar.
.IP "a glob-ref or IO::Handle object" 4
.IX Item "a glob-ref or IO::Handle object"
in which case again, the file is read and parsed.
.PP
The former case is for compatibility with older perls, but makes no
attempt to properly deal with character sets.  If you open a file in a
character-set-friendly way and then pass in a handle / object, then the
method should Do The Right Thing as it only ever works with character
data.
.PP
The remaining parameters are a list of key/value pairs to make a hash of
options:
.IP "fatal_declarations" 4
.IX Item "fatal_declarations"
If set to true, <!ENTITY...> and <!DOCTYPE...> declarations
in the document
are fatal errors \- otherwise they are *ignored*.
.IP "no_entity_parsing" 4
.IX Item "no_entity_parsing"
If set to true, the five built-in entities are passed through unparsed.
Note that special characters in \s-1CDATA\s0 and attributes may have been turned
into \f(CW\*(C`&amp;\*(C'\fR, \f(CW\*(C`&lt;\*(C'\fR and friends.
.IP "strict_entity_parsing" 4
.IX Item "strict_entity_parsing"
If set to true, any unrecognised entities (ie, those outside the core five
plus numeric entities) cause a fatal error.  If you set both this and
\&\f(CW\*(C`no_entity_parsing\*(C'\fR (but why would you do that?) then the latter takes
precedence.
.Sp
Obviously, if you want to maximise compliance with the \s-1XML\s0 spec, you should
turn on fatal_declarations and strict_entity_parsing.
.PP
The function returns a structure describing the document.  This contains
one or more nodes, each being either an 'element' node or a 'text' mode.
The structure is an arrayref which contains a single 'element' node which
represents the document entity.  The arrayref is redundant, but exists for
compatibility with XML::Parser::EasyTree.
.PP
Element nodes are hashrefs with the following keys:
.IP "type" 4
.IX Item "type"
The node's type, represented by the letter 'e'.
.IP "name" 4
.IX Item "name"
The element's name.
.IP "attrib" 4
.IX Item "attrib"
A hashref containing the element's attributes, as key/value pairs where
the key is the attribute name.
.IP "content" 4
.IX Item "content"
An arrayref of the element's contents.  The array's contents is a list of
nodes, in the order they were encountered in the document.
.PP
Text nodes are hashrefs with the following keys:
.IP "type" 4
.IX Item "type"
The node's type, represented by the letter 't'.
.IP "content" 4
.IX Item "content"
A scalar piece of text.
.PP
If you prefer a DOMmish interface, then look at XML::Tiny::DOM on the \s-1CPAN\s0.
.SH "COMPATIBILITY"
.IX Header "COMPATIBILITY"
.SS "With other modules"
.IX Subsection "With other modules"
The \f(CW\*(C`parsefile\*(C'\fR function is so named because it is intended to work in a
similar fashion to XML::Parser with the XML::Parser::EasyTree style.
Instead of saying this:
.PP
.Vb 5
\&  use XML::Parser;
\&  use XML::Parser::EasyTree;
\&  $XML::Parser::EasyTree::Noempty=1;
\&  my $p=new XML::Parser(Style=>\*(AqEasyTree\*(Aq);
\&  my $tree=$p\->parsefile(\*(Aqsomething.xml\*(Aq);
.Ve
.PP
you would say:
.PP
.Vb 2
\&  use XML::Tiny;
\&  my $tree = XML::Tiny::parsefile(\*(Aqsomething.xml\*(Aq);
.Ve
.PP
Any valid document that can be parsed like that using XML::Tiny should
produce identical results if you use the above example of how to use
XML::Parser::EasyTree.
.PP
If you find a document where that is not the case, please report it as
a bug.
.SS "With perl 5.004"
.IX Subsection "With perl 5.004"
The module is intended to be fully compatible with every version of perl
back to and including 5.004, and may be compatible with even older
versions of perl 5.
.PP
The lack of Unicode and friends in older perls means that XML::Tiny
does nothing with character sets.  If you have a document with a funny
character set, then you will need to open the file in an appropriate
mode using a character-set-friendly perl and pass the resulting file
handle to the module.  BOMs are ignored.
.SS "The subset of \s-1XML\s0 that we understand"
.IX Subsection "The subset of XML that we understand"
.IP "Element tags and attributes" 4
.IX Item "Element tags and attributes"
Including \*(L"self-closing\*(R" tags like <pie type = 'steak n kidney' />;
.IP "Comments" 4
.IX Item "Comments"
Which are ignored;
.ie n .IP "The five ""core"" entities" 4
.el .IP "The five ``core'' entities" 4
.IX Item "The five core entities"
ie \f(CW\*(C`&amp;\*(C'\fR, \f(CW\*(C`&lt;\*(C'\fR, \f(CW\*(C`&gt;\*(C'\fR, \f(CW\*(C`&apos;\*(C'\fR and \f(CW\*(C`&quot;\*(C'\fR;
.IP "Numeric entities" 4
.IX Item "Numeric entities"
eg \f(CW\*(C`&#65;\*(C'\fR and \f(CW\*(C`&#x41;\*(C'\fR;
.IP "\s-1CDATA\s0" 4
.IX Item "CDATA"
This is simply turned into \s-1PCDATA\s0 before parsing.  Note how this may interact
with the various entity-handling options;
.PP
The following parts of the \s-1XML\s0 standard are handled incorrectly or not at
all \- this is not an exhaustive list:
.IP "Namespaces" 4
.IX Item "Namespaces"
While documents that use namespaces will be parsed just fine, there's no
special treatment of them.  Their names are preserved in element and
attribute names like 'rdf:RDF'.
.IP "DTDs and Schemas" 4
.IX Item "DTDs and Schemas"
This is not a validating parser.  <!DOCTYPE...> declarations are ignored
if you've not made them fatal.
.IP "Entities and references" 4
.IX Item "Entities and references"
<!ENTITY...> declarations are ignored if you've not made them fatal.
Unrecognised entities are ignored by default, as are naked & characters.
This means that if entity parsing is enabled you won't be able to tell
the difference between \f(CW\*(C`&amp;nbsp;\*(C'\fR and \f(CW\*(C`&nbsp;\*(C'\fR.  If your
document might use any non-core entities then please consider using
the \f(CW\*(C`no_entity_parsing\*(C'\fR option, and then use something like
HTML::Entities.
.IP "Processing instructions" 4
.IX Item "Processing instructions"
These are ignored.
.IP "Whitespace" 4
.IX Item "Whitespace"
We do not guarantee to correctly handle leading and trailing whitespace.
.IP "Character sets" 4
.IX Item "Character sets"
This is not practical with older versions of perl
.SH "PHILOSOPHY and JUSTIFICATION"
.IX Header "PHILOSOPHY and JUSTIFICATION"
While feedback from real users about this module has been uniformly
positive and helpful, some people seem to take issue with this module
because it doesn't implement every last jot and tittle of the \s-1XML\s0
standard and merely implements a useful subset.  A very useful subset,
as it happens, which can cope with common light-weight XML-ish tasks
such as parsing the results of queries to the Amazon Web Services.
Many, perhaps most, users of \s-1XML\s0 do not in fact need a full implementation
of the standard, and are understandably reluctant to install large complex
pieces of software which have many dependencies.  In fact, when they
realise what installing and using a full implementation entails, they
quite often don't *want* it.  Another class of users, people
distributing applications, often can not rely on users being able to
install modules from the \s-1CPAN\s0, or even having tools like make or a shell
available.  XML::Tiny exists for those people.
.SH "BUGS and FEEDBACK"
.IX Header "BUGS and FEEDBACK"
I welcome feedback about my code, including constructive criticism.
Bug reports should be made using <http://rt.cpan.org/> or by email,
and should include the smallest possible chunk of code, along with
any necessary \s-1XML\s0 data, which demonstrates the bug.  Ideally, this
will be in the form of a file which I can drop in to the module's
test suite.  Please note that such files must work in perl 5.004.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "For more capable \s-1XML\s0 parsers:" 4
.IX Item "For more capable XML parsers:"
XML::Parser
.Sp
XML::Parser::EasyTree
.Sp
XML::Tiny::DOM
.IP "The requirements for a module to be Tiny" 4
.IX Item "The requirements for a module to be Tiny"
<http://beta.nntp.perl.org/group/perl.datetime/2007/01/msg6584.html>
.SH "AUTHOR, COPYRIGHT and LICENCE"
.IX Header "AUTHOR, COPYRIGHT and LICENCE"
David Cantrell <\fIdavid@cantrell.org.uk\fR>
.PP
Thanks to David Romano for some compatibility patches for Ye Aunciente Perl;
.PP
to Matt Knecht and David Romano for prodding me to support attributes,
and to Matt for providing code to implement it in a quick n dirty minimal
kind of way;
.PP
to the people on <http://use.perl.org/> and elsewhere who have been kind
enough to point out ways it could be improved;
.PP
to Sergio Fanchiotti for pointing out a bug in handling self-closing tags,
for reporting another bug that I introduced when fixing the first one,
and for providing a patch to improve error reporting;
.PP
to 'Corion' for finding a bug with localised filehandles and providing a fix;
.PP
to Diab Jerius for spotting that element and attribute names can begin
with an underscore;
.PP
to Nick Dumas for finding a bug when attribs have their quoting character
in \s-1CDATA\s0, and providing a patch;
.PP
to Mathieu Longtin for pointing out that BOMs exist.
.PP
Copyright 2007\-2010 David Cantrell <david@cantrell.org.uk>
.PP
This software is free-as-in-speech software, and may be used,
distributed, and modified under the terms of either the \s-1GNU\s0
General Public Licence version 2 or the Artistic Licence.  It's
up to you which one you use.  The full text of the licences can
be found in the files \s-1GPL2\s0.txt and \s-1ARTISTIC\s0.txt, respectively.
.SH "CONSPIRACY"
.IX Header "CONSPIRACY"
This module is also free-as-in-mason software.
