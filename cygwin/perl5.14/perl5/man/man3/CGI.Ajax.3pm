.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\" ========================================================================
.\"
.IX Title "CGI::Ajax 3"
.TH CGI::Ajax 3 "2008-10-08" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Ajax \- a perl\-specific system for writing Asynchronous web
applications
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use strict;
\&  use CGI;      # or any other CGI:: form handler/decoder
\&  use CGI::Ajax;
\&
\&  my $cgi = new CGI;
\&  my $pjx = new CGI::Ajax( \*(Aqexported_func\*(Aq => \e&perl_func );
\&  print $pjx\->build_html( $cgi, \e&Show_HTML);
\&
\&  sub perl_func {
\&    my $input = shift;
\&    # do something with $input
\&    my $output = $input . " was the input!";
\&    return( $output );
\&  }
\&
\&  sub Show_HTML {
\&    my $html = <<EOHTML;
\&    <HTML>
\&    <BODY>
\&      Enter something: 
\&        <input type="text" name="val1" id="val1"
\&         onkeyup="exported_func( [\*(Aqval1\*(Aq], [\*(Aqresultdiv\*(Aq] );">
\&      <br>
\&      <div id="resultdiv"></div>
\&    </BODY>
\&    </HTML>
\&  EOHTML
\&    return $html;
\&  }
.Ve
.PP
When you use CGI::Ajax within Applications that send their own header information,
you can skip the header:
.PP
.Vb 5
\&  my $pjx = new CGI::Ajax(
\&    \*(Aqexported_func\*(Aq => \e&perl_func,
\&    \*(Aqskip_header\*(Aq   => 1,
\&  );
\&  $pjx\->skip_header(1);
\&  
\&  print $pjx\->build_html( $cgi, \e&Show_HTML);
.Ve
.PP
\&\fIThere are several fully-functional examples in the 'scripts/'
directory of the distribution.\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CGI::Ajax is an object-oriented module that provides a unique
mechanism for using perl code asynchronously from javascript\-
enhanced \s-1HTML\s0 pages.  CGI::Ajax unburdens the user from having to
write extensive javascript, except for associating an exported
method with a document-defined event (such as onClick, onKeyUp,
etc).  CGI::Ajax also mixes well with \s-1HTML\s0 containing more complex
javascript.
.PP
CGI::Ajax supports methods that return single results or multiple
results to the web page, and supports returning values to multiple
\&\s-1DIV\s0 elements on the \s-1HTML\s0 page.
.PP
Using CGI::Ajax, the \s-1URL\s0 for the \s-1HTTP\s0 \s-1GET/POST\s0 request is
automatically generated based on \s-1HTML\s0 layout and events, and the
page is then dynamically updated with the output from the perl
function.  Additionally, CGI::Ajax supports mapping \s-1URL\s0's to a
CGI::Ajax function name, so you can separate your code processing
over multiple scripts.
.PP
Other than using the Class::Accessor module to generate CGI::Ajax'
accessor methods, CGI::Ajax is completely self-contained \- it
does not require you to install a larger package or a full Content
Management System, etc.
.PP
We have added \fIsupport\fR for other \s-1CGI\s0 handler/decoder modules,
like CGI::Simple or CGI::Minimal, but we can't test these
since we run mod_perl2 only here.  CGI::Ajax checks to see if a
\&\fIheader()\fR method is available to the \s-1CGI\s0 object, and then uses it.
If \fImethod()\fR isn't available, it creates it's own minimal header.
.PP
A primary goal of CGI::Ajax is to keep the module streamlined and
maximally flexible.  We are trying to keep the generated javascript
code to a minimum, but still provide users with a variety of
methods for deploying CGI::Ajax. And \s-1VERY\s0 little user javascript.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The CGI::Ajax module allows a Perl subroutine to be called
asynchronously, when triggered from a javascript event on the
\&\s-1HTML\s0 page.  To do this, the subroutine must be \fIregistered\fR,
usually done during:
.PP
.Vb 1
\&  my $pjx = new CGI::Ajax( \*(AqJSFUNC\*(Aq => \e&PERLFUNC );
.Ve
.PP
This maps a perl subroutine (\s-1PERLFUNC\s0) to an automatically
generated Javascript function (\s-1JSFUNC\s0).  Next you setup a trigger this
function when an event occurs (e.g. \*(L"onClick\*(R"):
.PP
.Vb 1
\&  onClick="JSFUNC([\*(Aqsource1\*(Aq,\*(Aqsource2\*(Aq], [\*(Aqdest1\*(Aq,\*(Aqdest2\*(Aq]);"
.Ve
.PP
where 'source1', 'dest1', 'source2', 'dest2' are the \s-1DIV\s0 ids of
\&\s-1HTML\s0 elements in your page...
.PP
.Vb 4
\&  <input type=text id=source1>
\&  <input type=text id=source2>
\&  <div id=dest1></div>
\&  <div id=dest2></div>
.Ve
.PP
CGI::Ajax sends the values from source1 and source2 to your
Perl subroutine and returns the results to dest1 and dest2.
.SS "4 Usage Methods"
.IX Subsection "4 Usage Methods"
.IP "1 Standard CGI::Ajax example" 4
.IX Item "1 Standard CGI::Ajax example"
Start by defining a perl subroutine that you want available from
javascript.  In this case we'll define a subrouting that determines
whether or not an input is odd, even, or not a number (NaN):
.Sp
.Vb 3
\&  use strict;
\&  use CGI::Ajax;
\&  use CGI;
\&
\&
\&  sub evenodd_func {
\&    my $input = shift;
\&
\&    # see if input is defined
\&    if ( not defined $input ) {
\&      return("input not defined or NaN");
\&    }
\&
\&    # see if value is a number (*thanks Randall!*)
\&    if ( $input !~ /\eA\ed+\ez/ ) {
\&      return("input is NaN");
\&    }
\&
\&    # got a number, so mod by 2
\&    $input % 2 == 0 ? return("EVEN") : return("ODD");
\&  }
.Ve
.Sp
Alternatively, we could have used coderefs to associate an
exported name...
.Sp
.Vb 3
\&  my $evenodd_func = sub {
\&    # exactly the same as in the above subroutine
\&  };
.Ve
.Sp
Next we define a function to generate the web page \- this can
be done many different ways, and can also be defined as an
anonymous sub.  The only requirement is that the sub send back
the html of the page.  You can do this via a string containing the
html, or from a coderef that returns the html, or from a function
(as shown here)...
.Sp
.Vb 10
\&  sub Show_HTML {
\&    my $html = <<EOT;
\&  <HTML>
\&  <HEAD><title>CGI::Ajax Example</title>
\&  </HEAD>
\&  <BODY>
\&    Enter a number:&nbsp;
\&    <input type="text" name="somename" id="val1" size="6"
\&       OnKeyUp="evenodd( [\*(Aqval1\*(Aq], [\*(Aqresultdiv\*(Aq] );">
\&    <br>
\&    <hr>
\&    <div id="resultdiv">
\&    </div>
\&  </BODY>
\&  </HTML>
\&EOT
\&    return $html;
\&  }
.Ve
.Sp
The exported Perl subrouting is triggered using the \f(CW\*(C`OnKeyUp\*(C'\fR
event handler of the input \s-1HTML\s0 element.  The subroutine takes one
value from the form, the input element \fB'val1'\fR, and returns the
the result to an \s-1HTML\s0 div element with an id of \fB'resultdiv'\fR.
Sending in the input id in an array format is required to support
multiple inputs, and similarly, to output multiple the results,
you can use an array for the output divs, but this isn't mandatory \-
as will be explained in the \fBAdvanced\fR usage.
.Sp
Now create a \s-1CGI\s0 object and a CGI::Ajax object, associating a reference
to our subroutine with the name we want available to javascript.
.Sp
.Vb 2
\&  my $cgi = new CGI();
\&  my $pjx = new CGI::Ajax( \*(Aqevenodd\*(Aq => \e&evenodd_func );
.Ve
.Sp
And if we used a coderef, it would look like this...
.Sp
.Vb 1
\&  my $pjx = new CGI::Ajax( \*(Aqevenodd\*(Aq => $evenodd_func );
.Ve
.Sp
Now we're ready to print the output page; we send in the cgi
object and the HTML-generating function.
.Sp
.Vb 1
\&  print $pjx\->build_html($cgi,\e&Show_HTML);
.Ve
.Sp
CGI::Ajax has support for passing in extra \s-1HTML\s0 header information
to the \s-1CGI\s0 object.  This can be accomplished by adding a third
argument to the \fIbuild_html()\fR call.  The argument needs to be a
hashref containing Key=>value pairs that \s-1CGI\s0 objects understand:
.Sp
.Vb 2
\&  print $pjx\->build_html($cgi,\e&Show_HTML,
\&    {\-charset=>\*(AqUTF\-8, \-expires=>\*(Aq\-1d\*(Aq});
.Ve
.Sp
See \s-1CGI\s0 for more \fIheader()\fR method options.  (\s-1CGI\s0.pm, not the 
Perl6 \s-1CGI\s0)
.Sp
That's it for the CGI::Ajax standard method.  Let's look at
something more advanced.
.IP "2 Advanced CGI::Ajax example" 4
.IX Item "2 Advanced CGI::Ajax example"
Let's say we wanted to have a perl subroutine process multiple
values from the \s-1HTML\s0 page, and similarly return multiple values
back to distinct divs on the page.  This is easy to do, and
requires no changes to the perl code \- you just create it as you
would any perl subroutine that works with multiple input values
and returns multiple values.  The significant change happens in
the event handler javascript in the \s-1HTML\s0...
.Sp
.Vb 1
\&  onClick="exported_func([\*(Aqinput1\*(Aq,\*(Aqinput2\*(Aq],[\*(Aqresult1\*(Aq,\*(Aqresult2\*(Aq]);"
.Ve
.Sp
Here we associate our javascript function (\*(L"exported_func\*(R") with
two \s-1HTML\s0 element ids ('input1','input2'), and also send in two
\&\s-1HTML\s0 element ids to place the results in ('result1','result2').
.IP "3 Sending Perl Subroutine Output to a Javascript function" 4
.IX Item "3 Sending Perl Subroutine Output to a Javascript function"
Occassionally, you might want to have a custom javascript function
process the returned information from your Perl subroutine.
This is possible, and the only requierment is that you change
your event handler code...
.Sp
.Vb 1
\&  onClick="exported_func([\*(Aqinput1\*(Aq],[js_process_func]);"
.Ve
.Sp
In this scenario, \f(CW\*(C`js_process_func\*(C'\fR is a javascript function you
write to take the returned value from your Perl subroutine and
process the results.  \fINote that a javascript function is not
quoted \*(-- if it were, then CGI::Ajax would look for a \s-1HTML\s0 element
with that id.\fR  Beware that with this usage, \fByou are responsible
for distributing the results to the appropriate place on the
\&\s-1HTML\s0 page\fR.  If the exported Perl subroutine returns, e.g. 2
values, then \f(CW\*(C`js_process_func\*(C'\fR would need to process the input
by working through an array, or using the javascript Function
\&\f(CW\*(C`arguments\*(C'\fR object.
.Sp
.Vb 7
\&  function js_process_func() {
\&    var input1 = arguments[0]
\&    var input2 = arguments[1];
\&    // do something and return results, or set HTML divs using
\&    // innerHTML
\&    document.getElementById(\*(Aqoutputdiv\*(Aq).innerHTML = input1;
\&  }
.Ve
.IP "4 URL/Outside Script CGI::Ajax example" 4
.IX Item "4 URL/Outside Script CGI::Ajax example"
There are times when you may want a different script to
return content to your page.  This could be because you have
an existing script already written to perform a particular
task, or you want to distribute a part of your application to another
script.  This can be accomplished in CGI::Ajax by using a \s-1URL\s0 in
place of a locally-defined Perl subroutine.  In this usage,
you alter you creation of the CGI::Ajax object to link an
exported javascript function name to a local \s-1URL\s0 instead of
a coderef or a subroutine.
.Sp
.Vb 2
\&  my $url = \*(Aqscripts/other_script.pl\*(Aq;
\&  my $pjx = new CGI::Ajax( \*(Aqexternal\*(Aq => $url );
.Ve
.Sp
This will work as before in terms of how it is called from you
event handler:
.Sp
.Vb 1
\&  onClick="external([\*(Aqinput1\*(Aq,\*(Aqinput2\*(Aq],[\*(Aqresultdiv\*(Aq]);"
.Ve
.Sp
The other_script.pl will get the values via a \s-1CGI\s0 object and
accessing the 'args' key.  The values of the \fB'args'\fR key will
be an array of everything that was sent into the script.
.Sp
.Vb 3
\&  my @input = $cgi\->params(\*(Aqargs\*(Aq);
\&  $input[0]; # contains first argument
\&  $input[1]; # contains second argument, etc...
.Ve
.Sp
This is good, but what if you need to send in arguments to the
other script which are directly from the calling Perl script,
i.e. you want a calling Perl script's variable to be sent, not
the value from an \s-1HTML\s0 element on the page?  This is possible
using the following syntax:
.Sp
.Vb 2
\&  onClick="exported_func([\*(Aqargs_\|_$input1\*(Aq,\*(Aqargs_\|_$input2\*(Aq],
\&                         [\*(Aqresultdiv\*(Aq]);"
.Ve
.Sp
Similary, if the external script required a constant as input
(e.g.  \f(CW\*(C`script.pl?args=42\*(C'\fR, you would use this syntax:
.Sp
.Vb 1
\&  onClick="exported_func([\*(Aqargs_\|_42\*(Aq],[\*(Aqresultdiv\*(Aq]);"
.Ve
.Sp
In both of the above examples, the result from the external
script would get placed into the \fIresultdiv\fR element on our
(the calling script's) page.
.Sp
If you are sending more than one argument from an external perl
script back to a javascript function, you will need to split the
string (\s-1AJAX\s0 applications communicate in strings only) on something.
Internally, we use '_\|_pjx_\|_', and this string is checked for.  If
found, CGI::Ajax will automatically split it.  However, if you
don't want to use '_\|_pjx_\|_', you can do it yourself:
.Sp
For example, from your Perl script, you would...
.Sp
.Vb 1
\&        return("A|B"); # join with "|"
.Ve
.Sp
and then in the javascript function you would have something like...
.Sp
.Vb 5
\&        process_func() {
\&                var arr = arguments[0].split("|");
\&                // arr[0] eq \*(AqA\*(Aq
\&                // arr[1] eq \*(AqB\*(Aq
\&        }
.Ve
.Sp
In order to rename parameters, in case the outside script needs
specifically-named parameters and not CGI::Ajax' \fI'args'\fR default
parameter name, change your event handler associated with an \s-1HTML\s0
event like this
.Sp
.Vb 2
\&  onClick="exported_func([\*(Aqmyname_\|_$input1\*(Aq,\*(Aqmyparam_\|_$input2\*(Aq],
\&                         [\*(Aqresultdiv\*(Aq]);"
.Ve
.Sp
The \s-1URL\s0 generated would look like this...
.Sp
\&\f(CW\*(C`script.pl?myname=input1&myparam=input2\*(C'\fR
.Sp
You would then retrieve the input in the outside script with this...
.Sp
.Vb 2
\&  my $p1 = $cgi\->params(\*(Aqmyname\*(Aq);
\&  my $p1 = $cgi\->params(\*(Aqmyparam\*(Aq);
.Ve
.Sp
Finally, what if we need to get a value from our \s-1HTML\s0 page and we
want to send that value to an outside script but the outside script
requires a named parameter different from \fI'args'\fR?  You can
accomplish this with CGI::Ajax using the \fIgetVal()\fR javascript
method (which returns an array, thus the \f(CW\*(C`getVal()[0]\*(C'\fR notation):
.Sp
.Vb 2
\&  onClick="exported_func([\*(Aqmyparam_\|_\*(Aq + getVal(\*(Aqdiv_id\*(Aq)[0]],
\&                         [\*(Aqresultdiv\*(Aq]);"
.Ve
.Sp
This will get the value of our \s-1HTML\s0 element with and
\&\fIid\fR of \fIdiv_id\fR, and submit it to the url attached to
\&\fImyparam_\|_\fR.  So if our exported handler referred to a \s-1URI\s0
called \fIscript/scr.pl\fR, and the element on our \s-1HTML\s0 page called
\&\fIdiv_id\fR contained the number '42', then the \s-1URL\s0 would look
like this \f(CW\*(C`script/scr.pl?myparam=42\*(C'\fR.  The result from this
outside \s-1URL\s0 would get placed back into our \s-1HTML\s0 page in the
element \fIresultdiv\fR.  See the example script that comes with
the distribution called \fIpjx_url.pl\fR and its associated outside
script \fIconvert_degrees.pl\fR for a working example.
.Sp
\&\fBN.B.\fR These examples show the use of outside scripts which
are other perl scripts \- \fIbut you are not limited to Perl\fR!
The outside script could just as easily have been \s-1PHP\s0 or any other
\&\s-1CGI\s0 script, as long as the return from the other script is just
the result, and not addition \s-1HTML\s0 code (like \s-1FORM\s0 elements, etc).
.SS "\s-1GET\s0 versus \s-1POST\s0"
.IX Subsection "GET versus POST"
Note that all the examples so far have used the following syntax:
.PP
.Vb 1
\&  onClick="exported_func([\*(Aqinput1\*(Aq],[\*(Aqresult1\*(Aq]);"
.Ve
.PP
There is an optional third argument to a CGI::Ajax exported
function that allows change the submit method.  The above event could
also have been coded like this...
.PP
.Vb 1
\&  onClick="exported_func([\*(Aqinput1\*(Aq],[\*(Aqresult1\*(Aq], \*(AqGET\*(Aq);"
.Ve
.PP
By default, CGI::Ajax sends a \fI'\s-1GET\s0'\fR request.  If you need it,
for example your \s-1URL\s0 is getting way too long, you can easily switch
to a \fI'\s-1POST\s0'\fR request with this syntax...
.PP
.Vb 1
\&  onClick="exported_func([\*(Aqinput1\*(Aq],[\*(Aqresult1\*(Aq], \*(AqPOST\*(Aq);"
.Ve
.PP
\&\fI('\s-1POST\s0' and 'post' are supported)\fR
.SS "Page Caching"
.IX Subsection "Page Caching"
We have implemented a method to prevent page cacheing from undermining
the \s-1AJAX\s0 methods in a page.  If you send in an input argument to a
CGI::Ajax\-exported function called '\s-1NO_CACHE\s0', the a special
parameter will get attached to the end or your url with a random
number in it.  This will prevent a browser from caching your request.
.PP
.Vb 1
\&  onClick="exported_func([\*(Aqinput1\*(Aq,\*(AqNO_CACHE\*(Aq],[\*(Aqresult1\*(Aq]);"
.Ve
.PP
The extra param is called pjxrand, and won't interfere with the order
of processing for the rest of your parameters.
.PP
Also see the \s-1\fICACHE\s0()\fR method of changing the default cache behavior.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fIbuild_html()\fR" 4
.IX Item "build_html()"
.Vb 12
\&    Purpose: Associates a cgi obj ($cgi) with pjx object, inserts
\&             javascript into <HEAD></HEAD> element and constructs
\&             the page, or part of the page.  AJAX applications
\&             are designed to update only the section of the
\&             page that needs it \- the whole page doesn\*(Aqt have
\&             to be redrawn.  L<CGI::Ajax> applications use the
\&             build_html() method to take care of this: if the CGI
\&             parameter C<fname> exists, then the return from the
\&             L<CGI::Ajax>\-exported function is sent to the page.
\&             Otherwise, the entire page is sent, since without
\&             an C<fname> param, this has to be the first time
\&             the page is being built.
\&
\&  Arguments: The CGI object, and either a coderef, or a string
\&             containing html.  Optionally, you can send in a third
\&             parameter containing information that will get passed
\&             directly to the CGI object header() call.
\&    Returns: html or updated html (including the header)
\&  Called By: originating cgi script
.Ve
.IP "\fIshow_javascript()\fR" 4
.IX Item "show_javascript()"
.Vb 8
\&    Purpose: builds the text of all the javascript that needs to be
\&             inserted into the calling scripts html <head> section
\&  Arguments:
\&    Returns: javascript text
\&  Called By: originating web script
\&       Note: This method is also overridden so when you just print
\&             a CGI::Ajax object it will output all the javascript needed
\&             for the web page.
.Ve
.IP "\fIregister()\fR" 4
.IX Item "register()"
.Vb 5
\&    Purpose: adds a function name and a code ref to the global coderef
\&             hash, after the original object was created
\&  Arguments: function name, code reference
\&    Returns: none
\&  Called By: originating web script
.Ve
.IP "\fIfname()\fR" 4
.IX Item "fname()"
.Vb 3
\&    Purpose: Overrides the default parameter name used for
\&             passing an exported function name. Default value
\&             is "fname".
\&
\&  Arguments: fname("new_name"); # sets the new parameter name
\&             The overriden fname should be consistent throughout 
\&             the entire application. Otherwise results are unpredicted.
\&
\&    Returns: With no parameters fname() returns the current fname name
.Ve
.IP "\s-1\fIJSDEBUG\s0()\fR" 4
.IX Item "JSDEBUG()"
.Vb 6
\&    Purpose: Show the AJAX URL that is being generated, and stop
\&             compression of the generated javascript, both of which can aid
\&             during debugging.  If set to 1, then the core js will get
\&             compressed, but the user\-defined functions will not be
\&             compressed.  If set to 2 (or anything greater than 1 or 0), 
\&             then none of the javascript will get compressed.
\&
\&  Arguments: JSDEBUG(0); # turn javascript debugging off
\&             JSDEBUG(1); # turn javascript debugging on, some javascript compression
\&             JSDEBUG(2); # turn javascript debugging on, no javascript compresstion
\&    Returns: prints a link to the url that is being generated automatically by
\&             the Ajax object. this is VERY useful for seeing what
\&             CGI::Ajax is doing. Following the link, will show a page
\&             with the output that the page is generating.
\&             
\&  Called By: $pjx\->JSDEBUG(1) # where $pjx is a CGI::Ajax object;
.Ve
.IP "\s-1\fIDEBUG\s0()\fR" 4
.IX Item "DEBUG()"
.Vb 6
\&    Purpose: Show debugging information in web server logs
\&  Arguments: DEBUG(0); # turn debugging off (default)
\&             DEBUG(1); # turn debugging on
\&    Returns: prints debugging information to the web server logs using
\&             STDERR
\&  Called By: $pjx\->DEBUG(1) # where $pjx is a CGI::Ajax object;
.Ve
.IP "\s-1\fICACHE\s0()\fR" 4
.IX Item "CACHE()"
.Vb 6
\&    Purpose: Alter the default result caching behavior.
\&  Arguments: CACHE(0); # effectively the same as having NO_CACHE passed in every call
\&    Returns: A change in the behavior of build_html such that the javascript
\&             produced will always act as if the NO_CACHE argument is passed,
\&             regardless of its presence.
\&  Called By: $pjx\->CACHE(0) # where $pjx is a CGI::Ajax object;
.Ve
.SH "BUGS"
.IX Header "BUGS"
Follow any bugs at our homepage....
.PP
.Vb 1
\&  http://www.perljax.us
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
Check out the news/discussion/bugs lists at our homepage:
.PP
.Vb 1
\&  http://www.perljax.us
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 3
\&  Brian C. Thomas     Brent Pedersen
\&  CPAN ID: BCT
\&  bct.x42@gmail.com   bpederse@gmail.com
\&
\&  significant contribution by:
\&      Peter Gordon <peter@pg\-consultants.com> # CGI::Application + scripts
\&      Kyraha  http://michael.kyraha.com/      # getVal(), multiple forms
\&      Jan Franczak <jan.franczak@gmail.com>   # CACHE support
\&      Shibi NS                                # use \->isa instead of \->can
\&     
\&  others:
\&      RENEEB <RENEEB [...] cpan.org> 
\&      stefan.scherer
\&      RBS
\&      Andrew
.Ve
.SH "A NOTE ABOUT THE MODULE NAME"
.IX Header "A NOTE ABOUT THE MODULE NAME"
This module was initiated using the name \*(L"Perljax\*(R", but then
registered with \s-1CPAN\s0 under the \s-1WWW\s0 group \*(L"\s-1CGI::\s0\*(R", and so became
\&\*(L"CGI::Perljax\*(R".  Upon further deliberation, we decided to change it's
name to CGI::Ajax.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Javascript
\&\s-1CGI\s0
Class::Accessor
